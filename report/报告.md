[//]: # (报告制作思路)

注释尽量详细, 写报告用

# Baseline

首先我制作了 `baselineSearch` 函数, 其在测试集上的效率是 ...

[//]: # (补充省略号内容, 看 baselineSearch 注释)

![baseline-profile.png](img/baseline-profile.png)

发现选中项 contains 有不必要的时间占用.

# Baseline With HashSet

于是我将 HashSet 应用到 `baselineSearch` 索引的保存中, 并将 hashSet 设置为 1000.

![baseline-with-hashset-profile.png](img/baseline-with-hashset-profile.png)

得到了小许优化.

# HNSW

通过[向量数据库](https://www.bilibili.com/video/BV14u4y1A7fB?p=4)视频, 我了解到了 HNSW 算法,
用于查找与目标向量最接近的一个向量.

## HNSW-TopK

但是我第一眼看去 HNSW 只能用于查找最近的一个向量, 并没有直接看出如何使用 HNSW 如何应用到 TopK 问题上.

### 优先队列

于是我问 gpt, 它说用优先队列来实现最近 k 个节点的获取.

优先队列中堆顶是距离目标点最远的点, 每次弹出堆顶, 然后如果弹出的节点有比此节点距离目标向量更近的邻居节点,
且此邻居节点不在优先队列内, 则将邻居节点添加进优先队列中.

### 优先队列包含的问题

如果搜索完, 结果没有 k 个, 可能的情况为:

1. 层中没有足够的点.
2. 搜索的起始点和目标点足够近.

### 优先队列问题的解决方案

第一点实际上没什么问题, 此情况一般只会在层构建初期才会产生, 就算在查询是出现此情况, 也影响不大.

对于第二点, 我自己想的思路是, 如果优先队列的元素数量没有达到 k 那就不检查邻居节点与目标向量的距离,
直接放入堆中 (重复性还是要检查的).

### 解决优先队列比较里的重复计算和重复性检查

要把优先队列应用下来, 还需要一个步骤: 缓冲每个节点和目标向量的距离.
原因是在优先队列中, 需要进行多次比较, 若不缓冲则会造成重复的运算.

对此我的设计是:
每个 Layer 维护一个独特的 `searchBatch:int`, 用于记录搜索批次, 每调用一次 `searchNearestTopK`, 此值自增.
Layer 中的每个 GraphNode 添加两个字段: `{ batch:int, inQueue:bool, distance:double }`,
分别代表缓冲的距离所属的搜索批次, 是否在队列里和缓冲的距离.

这三个字段不仅可以减少重复的计算, 还能用于[重复性检查](#优先队列问题的解决方案),
如果 `batch != searchBatch`, 就说明此节点在此次搜索中没有被涉及到,
此时 inQueue 和 distance 的值需要重新设置和计算.
如果 `batch == searchBatch`, 说明此次搜索层涉及过此节点, 那么 distance 字段可以直接使用, inQueue
字段用来判断此节点是否在优先级队列里, 防止反复添加.

最后放进优先队列里的是 GraphNode 的指针, 同时传入一个比较函数给优先队列, 由于取得 distance 并比较.
此处的想法一开始困扰了我一会, 我的几个原有的想法是:

1. 优先队列里存放 GraphNode 的包裹类.
2. 优先队列里存放 GraphNode 在 Layer 中的索引.

这几个想法由于以下缺陷而取消了:

1. 包裹类内存开销太大, 每次搜索都要进行多次内存的分配
2. 如果只传入索引, 那么在比较时获取 distance 的值就需要一个 Layer 的引用, 于是在比较函数中就需要拥有
   Layer 的指针, 但是成员函数并不能作为函数指针传递, 于是获取 Layer 的引用就比较困难.

### 层内搜索步骤

搜索分为层内和多层, 这里先介绍单层的搜索, 层间搜索的切换稍后再讲.

**注意**:
以下步骤中,

- 每次使用节点的缓冲距离时, 需要提前计算.
- 每次从优先级队列中放入值前需要设置 inQueue.
- 每次从优先级队列中弹出值时需要设置 inQueue.

下文省略不谈.

步骤为:

1. 如果 Layer 的节点数量小于等于 k, 直接把 Layer 中所有的节点索引返回.
2. 从 Layer 中的第一个节点开始, 把此节点放入优先级队列(pq: `PriorityQueue<GraphNode *>`,
   堆顶存放着距离最远的节点).
3. 循环, 直到 pq 为空 (pq 为空估计不会出现):
    1. 弹出 pq 顶上的元素 node.
    2. 遍历 node 的每个邻居, 当 pq 大小小于 k (TopK 的 k) 时, 直接添加此邻居,
       否则只有当邻居的距离比 node 近时才添加此邻居.
    3. 如果此 node 没有邻居被添加, 结束循环, 此时说明: pq 的大小一定大于等于 k.
       **注意**: 不会有节点被逼在最远的角落而无法取得更近的邻居, 因为如果最远的节点被添加进来(pq
       大小小于 k 时无视距离直接添加), 那么导致这个节点被添加进来的节点会在之前被弹出,
       此时最远节点可以找到这个节点作为更近邻居 (distance 更小).
4. 